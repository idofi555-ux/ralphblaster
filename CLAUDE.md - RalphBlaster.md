# [CLAUDE.md](http://CLAUDE.md) \- RalphBlaster Development Automation System

\#\# Project Overview

Build \*\*RalphBlaster\*\* \- an autonomous development workflow system that transforms ticket-driven development into fully automated code generation using Claude Code.

\*\*The Core Workflow:\*\*

1. User creates a ticket (title \+ description)  
2. 2\. User clicks “Generate PRD” button  
3. 3\. System generates structured PRD using Claude CLI  
4. 4\. User reviews and approves PRD  
5. 5\. Ralph executes PRD autonomously in isolated worktree  
6. 6\. User gets notified when complete  
7. 7\. Files clean up automatically

\#\# Tech Stack

- \*\*Frontend\*\*: [Next.js](http://Next.js) 14+ with App Router  
- \- \*\*Backend\*\*: [Next.js](http://Next.js) API Routes  
- \- \*\*Database\*\*: PostgreSQL with Prisma ORM  
- \- \*\*Styling\*\*: Tailwind CSS  
- \- \*\*Real-time\*\*: Server-Sent Events (SSE) for progress updates  
- \- \*\*CLI Integration\*\*: Claude CLI (\`claude –print\`)

\#\# Project Structure

\`\`\`  
ralphblaster/  
├── app/  
│   ├── page.tsx                    \# Main Kanban board  
│   ├── layout.tsx                  \# Root layout  
│   ├── api/  
│   │   ├── projects/  
│   │   │   └── [route.ts](http://route.ts)            \# CRUD for projects  
│   │   ├── tickets/  
│   │   │   ├── [route.ts](http://route.ts)            \# CRUD for tickets  
│   │   │   ├── \[id\]/  
│   │   │   │   ├── [route.ts](http://route.ts)        \# Single ticket operations  
│   │   │   │   ├── generate-prd/  
│   │   │   │   │   └── [route.ts](http://route.ts)    \# PRD generation endpoint  
│   │   │   │   ├── start-ralph/  
│   │   │   │   │   └── [route.ts](http://route.ts)    \# Start Ralph execution  
│   │   │   │   └── ralph-status/  
│   │   │   │       └── [route.ts](http://route.ts)    \# SSE for Ralph progress  
│   │   │   └── [route.ts](http://route.ts)  
│   └── globals.css  
├── components/  
│   ├── KanbanBoard.tsx             \# Main board component  
│   ├── KanbanColumn.tsx            \# Column component  
│   ├── TicketCard.tsx              \# Ticket card component  
│   ├── CreateTicketModal.tsx       \# Ticket creation modal  
│   ├── TicketDetailModal.tsx       \# Ticket detail view with PRD  
│   ├── PRDViewer.tsx               \# PRD display component  
│   ├── RalphProgress.tsx           \# Real-time progress display  
│   └── ProjectSelector.tsx         \# Project dropdown  
├── lib/  
│   ├── [prisma.ts](http://prisma.ts)                   \# Prisma client  
│   ├── [claude.ts](http://claude.ts)                   \# Claude CLI integration  
│   ├── [ralph.ts](http://ralph.ts)                    \# Ralph execution logic  
│   └── [utils.ts](http://utils.ts)                    \# Utility functions  
├── prisma/  
│   └── schema.prisma               \# Database schema  
├── ralph-instances/                \# Created at runtime  
│   └── \[ticket-slug\]-\[timestamp\]/  \# Per-ticket execution dirs  
├── scripts/  
│   └── [ralph-execute.sh](http://ralph-execute.sh)            \# Ralph execution script  
└── types/  
    └── [index.ts](http://index.ts)                    \# TypeScript types  
\`\`\`

\#\# Database Schema (Prisma)

\`\`\`prisma  
// prisma/schema.prisma

Generator client {  
  Provider \= “prisma-client-js”  
}

Datasource db {  
  Provider \= “postgresql”  
  Url      \= env(“DATABASE\_URL”)  
}

Model Project {  
  Id        String   

| To |   Name      String   codePath  String   // Local path to codebase, e.g., “/Users/me/dev/myproject”   Color     String   @default(“\#3B82F6”) // Blue default   createdAt DateTime @default(now())   updatedAt DateTime @updatedAt   Tickets   Ticket\[\] } Model Ticket {   Id                String       @id @default(cuid())   Title             String   Description       String       @db.Text   Status            TicketStatus @default(BACKLOG)   Priority          Priority     @default(MEDIUM)      // PRD fields   prdContent        String?      @db.Text   prdGeneratedAt    DateTime?      // Ralph execution fields   ralphInstancePath String?   ralphStatus       RalphStatus?   ralphStartedAt    DateTime?   ralphCompletedAt  DateTime?   ralphLogs         String?      @db.Text      // Relations   Project           Project      @relation(fields: \[projectId\], references: \[id\])   projectId         String      createdAt         DateTime     @default(now())   updatedAt         DateTime     @updatedAt } Enum TicketStatus {   BACKLOG   UP\_NEXT   IN\_REVIEW   IN\_PROGRESS   IN\_TESTING   COMPLETED } Enum Priority {   LOW   MEDIUM   HIGH } Enum RalphStatus {   LAUNCHING   RUNNING   COMPLETED   FAILED } \`\`\` \#\# Implementation Tasks \#\#\# Phase 1: Core Setup \[ \] Initialize [Next.js](http://Next.js) project with TypeScript \- \[ \] Set up Prisma with PostgreSQL \- \[ \] Create database schema and run migrations \- \[ \] Set up Tailwind CSS \- \[ \] Create basic layout and navigation \#\#\# Phase 2: Project Management \- \[ \] Create Project model and API routes \- \[ \] Build ProjectSelector component \- \[ \] Implement project CRUD operations \- \[ \] Add project settings modal (name, codePath, color) \#\#\# Phase 3: Kanban Board \- \[ \] Create KanbanBoard component with 6 columns \- \[ \] Implement drag-and-drop with @dnd-kit \- \[ \] Create TicketCard component \- \[ \] Add ticket status transitions \#\#\# Phase 4: Ticket Management \- \[ \] Create CreateTicketModal component \- \[ \] Implement ticket CRUD API routes \- \[ \] Build TicketDetailModal component \- \[ \] Add ticket editing functionality \#\#\# Phase 5: PRD Generation \- \[ \] Create Claude CLI integration in lib/[claude.ts](http://claude.ts) \- \[ \] Build PRD generation API endpoint \- \[ \] Create PRDViewer component \- \[ \] Add “Generate PRD” button to ticket modal \- \[ \] Display generated PRD with approval UI \#\#\# Phase 6: Ralph Execution \- \[ \] Create [ralph-execute.sh](http://ralph-execute.sh) script \- \[ \] Build Ralph execution logic in lib/[ralph.ts](http://ralph.ts) \- \[ \] Implement SSE endpoint for progress updates \- \[ \] Create RalphProgress component \- \[ \] Add instance directory management \- \[ \] Implement cleanup on completion \#\#\# Phase 7: Polish \- \[ \] Add notifications (toast messages) \- \[ \] Implement error handling \- \[ \] Add loading states \- \[ \] Create responsive design \- \[ \] Add keyboard shortcuts \#\# Key Files to Implement \#\#\# 1\. lib/[claude.ts](http://claude.ts) \- Claude CLI Integration \`\`\`typescript Import { exec } from ‘child\_process’; Import { promisify } from ‘util’; Const execAsync \= promisify(exec); Export async function generatePRD(ticket: { title: string; description: string }, projectPath: string): Promise\<string\> {   Const prompt \= buildPRDPrompt(ticket, projectPath);      Try {     Const { stdout } \= await execAsync(       \`claude –print “${prompt.replace(/”/g, ‘\\\\”’)}”\`,       {          Timeout: 300000, // 5 minute timeout         maxBuffer: 1024 \* 1024 \* 10 // 10MB buffer       }     );     Return stdout;   } catch (error) {     Throw new Error(\`PRD generation failed: ${error}\`);   } } Function buildPRDPrompt(ticket: { title: string; description: string }, projectPath: string): string {   Return \`You are a product manager creating a PRD. Generate a structured PRD for this ticket: Title: ${ticket.title} Description: ${ticket.description} Project Path: ${projectPath} Create a PRD with these sections: 1\. Overview \- Brief summary 2\. User Stories \- In format “As a \[role\], I want \[feature\], So that \[benefit\]” 3\. Acceptance Criteria \- Testable requirements 4\. Technical Notes \- Implementation hints Format as clean markdown.\`; } \`\`\` \#\#\# 2\. lib/[ralph.ts](http://ralph.ts) \- Ralph Execution \`\`\`typescript Import { spawn } from ‘child\_process’; Import \* as fs from ‘fs/promises’; Import \* as path from ‘path’; Export interface RalphInstance {   instancePath: string;   ticketSlug: string;   Timestamp: string; } Export async function createRalphInstance(   Ticket: { id: string; title: string; prdContent: string },   projectPath: string ): Promise\<RalphInstance\> {   Const timestamp \= new Date().toISOString().replace(/\[:.\]/g, ‘-’);   Const ticketSlug \= ticket.title.toLowerCase().replace(/\[^a-z0-9\]+/g, ‘-’).slice(0, 50);   Const instanceName \= \`${ticketSlug}-${timestamp}\`;   Const instancePath \= path.join(process.cwd(), ‘ralph-instances’, instanceName);   // Create instance directory   Await fs.mkdir(instancePath, { recursive: true });   // Write PRD   Await fs.writeFile(path.join(instancePath, ‘[source-prd.md](http://source-prd.md)’), ticket.prdContent);   // Write progress file   Await fs.writeFile(     path.join(instancePath, ‘[progress.md](http://progress.md)’),     \`\# Ralph Progress Log\\nCreated: ${new Date().toISOString()}\\n\\n\`   );   Return { instancePath, ticketSlug, timestamp }; } Export async function executeRalph(   Instance: RalphInstance,   projectPath: string,   onProgress: (log: string) \=\> void ): Promise\<void\> {   Return new Promise((resolve, reject) \=\> {     Const ralph \= spawn(‘claude’, \[       ‘--print’,       ‘--dangerously-skip-permissions’,       \`Read the PRD at ${instance.instancePath}/[source-prd.md](http://source-prd.md) and implement all tasks.         Work in the codebase at ${projectPath}.        Log progress to ${instance.instancePath}/[progress.md](http://progress.md).        Commit each completed task.\`     \], {       Cwd: projectPath,       Shell: true     });     [ralph.stdout.on](http://ralph.stdout.on)(‘data’, (data) \=\> {       onProgress(data.toString());     });     [ralph.stderr.on](http://ralph.stderr.on)(‘data’, (data) \=\> {       onProgress(\`ERROR: ${data.toString()}\`);     });     [ralph.on](http://ralph.on)(‘close’, (code) \=\> {       If (code \=== 0\) {         resolve();       } else {         reject(new Error(\`Ralph exited with code ${code}\`));       }     });   }); } \`\`\` \#\#\# 3\. scripts/[ralph-execute.sh](http://ralph-execute.sh) \`\`\`bash \#\!/bin/bash INSTANCE\_DIR=”$1” PROJECT\_PATH=”$2” PRD\_FILE=”$INSTANCE\_DIR/[source-prd.md](http://source-prd.md)” PROGRESS\_FILE=”$INSTANCE\_DIR/[progress.md](http://progress.md)” \# Log function log() {     Echo “\[$(date ‘+%Y-%m-%d %H:%M:%S’)\] $1” \>\> “$PROGRESS\_FILE”     Echo “\[$(date ‘+%Y-%m-%d %H:%M:%S’)\] $1” } Log “Starting Ralph execution” Log “Instance: $INSTANCE\_DIR” Log “Project: $PROJECT\_PATH” \# Change to project directory Cd “$PROJECT\_PATH” || exit 1 \# Create worktree for isolated development BRANCH\_NAME=”ralph/$(basename “$INSTANCE\_DIR”)” Git worktree add “$INSTANCE\_DIR/worktree” \-b “$BRANCH\_NAME” 2\>/dev/null || true Log “Created worktree: $BRANCH\_NAME” \# Execute Claude with the PRD Log “Invoking Claude Code…” Claude –print “ You are an autonomous coding agent. Your task is to implement the PRD. PRD Location: $PRD\_FILE Working Directory: $INSTANCE\_DIR/worktree Instructions: 1\. Read the PRD file 2\. Implement each user story 3\. Write tests for each feature 4\. Commit after each completed task 5\. Log progress to $PROGRESS\_FILE Begin implementation now. “ Log “Ralph execution completed” \`\`\` \#\#\# 4\. components/KanbanBoard.tsx \`\`\`tsx ‘Use client’; Import { useState, useEffect } from ‘react’; Import { DndContext, closestCenter, DragEndEvent } from ‘@dnd-kit/core’; Import KanbanColumn from ‘./KanbanColumn’; Import CreateTicketModal from ‘./CreateTicketModal’; Import TicketDetailModal from ‘./TicketDetailModal’; Const COLUMNS \= \[   { id: ‘BACKLOG’, title: ‘Backlog’, color: ‘gray’ },   { id: ‘UP\_NEXT’, title: ‘Up Next’, color: ‘yellow’ },   { id: ‘IN\_REVIEW’, title: ‘In Review’, color: ‘purple’ },   { id: ‘IN\_PROGRESS’, title: ‘In Progress’, color: ‘blue’ },   { id: ‘IN\_TESTING’, title: ‘In Testing’, color: ‘orange’ },   { id: ‘COMPLETED’, title: ‘Completed’, color: ‘green’ }, \]; Export default function KanbanBoard({ projectId }: { projectId: string }) {   Const \[tickets, setTickets\] \= useState(\[\]);   Const \[isCreateModalOpen, setIsCreateModalOpen\] \= useState(false);   Const \[selectedTicket, setSelectedTicket\] \= useState(null);   useEffect(() \=\> {     fetchTickets();   }, \[projectId\]);   Const fetchTickets \= async () \=\> {     Const res \= await fetch(\`/api/tickets?projectId=${projectId}\`);     Const data \= await res.json();     setTickets(data);   };   Const handleDragEnd \= async (event: DragEndEvent) \=\> {     Const { active, over } \= event;     If (\!over) return;     Const ticketId \= [active.id](http://active.id);     Const newStatus \= [over.id](http://over.id);     Await fetch(\`/api/tickets/${ticketId}\`, {       Method: ‘PATCH’,       Headers: { ‘Content-Type’: ‘application/json’ },       Body: JSON.stringify({ status: newStatus }),     });     fetchTickets();   };   Return (     \<div className=”h-full”\>       \<div className=”flex justify-between items-center mb-6”\>         \<h1 className=”text-2xl font-bold”\>RalphBlaster™\</h1\>         \<button           onClick={() \=\> setIsCreateModalOpen(true)}           className=”bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600”         \>           \+ New Ticket         \</button\>       \</div\>       \<DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}\>         \<div className=”flex gap-4 overflow-x-auto pb-4”\>           {COLUMNS.map((column) \=\> (             \<KanbanColumn               key={[column.id](http://column.id)}               column={column}               tickets={tickets.filter((t) \=\> t.status \=== [column.id](http://column.id))}               onTicketClick={setSelectedTicket}             /\>           ))}         \</div\>       \</DndContext\>       {isCreateModalOpen && (         \<CreateTicketModal           projectId={projectId}           onClose={() \=\> setIsCreateModalOpen(false)}           onCreated={fetchTickets}         /\>       )}       {selectedTicket && (         \<TicketDetailModal           ticket={selectedTicket}           onClose={() \=\> setSelectedTicket(null)}           onUpdated={fetchTickets}         /\>       )}     \</div\>   ); } \`\`\` \#\#\# 5\. components/TicketDetailModal.tsx \`\`\`tsx ‘Use client’; Import { useState } from ‘react’; Import PRDViewer from ‘./PRDViewer’; Import RalphProgress from ‘./RalphProgress’; Export default function TicketDetailModal({ ticket, onClose, onUpdated }) {   Const \[isGeneratingPRD, setIsGeneratingPRD\] \= useState(false);   Const \[isRalphRunning, setIsRalphRunning\] \= useState(false);   Const generatePRD \= async () \=\> {     setIsGeneratingPRD(true);     Try {       Const res \= await fetch(\`/api/tickets/${[ticket.id](http://ticket.id)}/generate-prd\`, {         Method: ‘POST’,       });       If ([res.ok](http://res.ok)) {         onUpdated();       }     } finally {       setIsGeneratingPRD(false);     }   };   Const startRalph \= async () \=\> {     setIsRalphRunning(true);     Try {       Const res \= await fetch(\`/api/tickets/${[ticket.id](http://ticket.id)}/start-ralph\`, {         Method: ‘POST’,       });       If ([res.ok](http://res.ok)) {         onUpdated();       }     } catch (error) {       setIsRalphRunning(false);     }   };   Return (     \<div className=”fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50”\>       \<div className=”bg-white rounded-lg max-w-4xl w-full max-h-\[90vh\] overflow-y-auto”\>         \<div className=”p-6”\>           \<div className=”flex justify-between items-start mb-4”\>             \<h2 className=”text-xl font-bold”\>{ticket.title}\</h2\>             \<button onClick={onClose} className=”text-gray-500 hover:text-gray-700”\>               ✕             \</button\>           \</div\>           \<div className=”mb-6”\>             \<h3 className=”font-semibold mb-2”\>Description\</h3\>             \<p className=”text-gray-700 whitespace-pre-wrap”\>{ticket.description}\</p\>           \</div\>           {/\* PRD Section \*/}           \<div className=”mb-6”\>             \<div className=”flex justify-between items-center mb-2”\>               \<h3 className=”font-semibold”\>Product Requirements Document\</h3\>               {\!ticket.prdContent && (                 \<button                   onClick={generatePRD}                   disabled={isGeneratingPRD}                   className=”bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 disabled:opacity-50”                 \>                   {isGeneratingPRD ? ‘Generating…’ : ‘Generate PRD’}                 \</button\>               )}             \</div\>             {ticket.prdContent && \<PRDViewer content={ticket.prdContent} /\>}           \</div\>           {/\* Ralph Execution Section \*/}           {ticket.prdContent && (             \<div className=”mb-6”\>               \<div className=”flex justify-between items-center mb-2”\>                 \<h3 className=”font-semibold”\>Ralph Execution\</h3\>                 {\!ticket.ralphStatus && (                   \<button                     onClick={startRalph}                     className=”bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600”                   \>                     Start Ralph                   \</button\>                 )}               \</div\>               {ticket.ralphStatus && (                 \<RalphProgress                    ticketId={[ticket.id](http://ticket.id)}                    status={ticket.ralphStatus}                 /\>               )}             \</div\>           )}         \</div\>       \</div\>     \</div\>   ); } \`\`\` \#\#\# 6\. API Route: app/api/tickets/\[id\]/generate-prd/[route.ts](http://route.ts) \`\`\`typescript Import { NextRequest, NextResponse } from ‘next/server’; Import { prisma } from ‘@/lib/prisma’; Import { generatePRD } from ‘@/lib/claude’; Export async function POST(   Request: NextRequest,   { params }: { params: { id: string } } ) {   Try {     Const ticket \= await prisma.ticket.findUnique({       Where: { id: [params.id](http://params.id) },       Include: { project: true },     });     If (\!ticket) {       Return NextResponse.json({ error: ‘Ticket not found’ }, { status: 404 });     }     Const prdContent \= await generatePRD(       { title: ticket.title, description: ticket.description },       ticket.project.codePath     );     Const updatedTicket \= await prisma.ticket.update({       Where: { id: [params.id](http://params.id) },       Data: {         prdContent,         prdGeneratedAt: new Date(),       },     });     Return NextResponse.json(updatedTicket);   } catch (error) {     console.error(‘PRD generation error:’, error);     Return NextResponse.json(       { error: ‘Failed to generate PRD’ },       { status: 500 }     );   } } \`\`\` \#\#\# 7\. API Route: app/api/tickets/\[id\]/start-ralph/[route.ts](http://route.ts) \`\`\`typescript Import { NextRequest, NextResponse } from ‘next/server’; Import { prisma } from ‘@/lib/prisma’; Import { createRalphInstance, executeRalph } from ‘@/lib/ralph’; Export async function POST(   Request: NextRequest,   { params }: { params: { id: string } } ) {   Try {     Const ticket \= await prisma.ticket.findUnique({       Where: { id: [params.id](http://params.id) },       Include: { project: true },     });     If (\!ticket || \!ticket.prdContent) {       Return NextResponse.json(         { error: ‘Ticket not found or PRD not generated’ },         { status: 400 }       );     }     // Create Ralph instance     Const instance \= await createRalphInstance(       { id: [ticket.id](http://ticket.id), title: ticket.title, prdContent: ticket.prdContent },       ticket.project.codePath     );     // Update ticket status     Await prisma.ticket.update({       Where: { id: [params.id](http://params.id) },       Data: {         ralphInstancePath: instance.instancePath,         ralphStatus: ‘LAUNCHING’,         ralphStartedAt: new Date(),         Status: ‘IN\_PROGRESS’,       },     });     // Start Ralph execution (async)     executeRalph(instance, ticket.project.codePath, async (log) \=\> {       Await prisma.ticket.update({         Where: { id: [params.id](http://params.id) },         Data: {           ralphLogs: { append: log \+ ‘\\n’ },           ralphStatus: ‘RUNNING’,         },       });     }).then(async () \=\> {       Await prisma.ticket.update({         Where: { id: [params.id](http://params.id) },         Data: {           ralphStatus: ‘COMPLETED’,           ralphCompletedAt: new Date(),           Status: ‘IN\_TESTING’,         },       });     }).catch(async (error) \=\> {       Await prisma.ticket.update({         Where: { id: [params.id](http://params.id) },         Data: {           ralphStatus: ‘FAILED’,           ralphLogs: { append: \`\\nFAILED: ${error.message}\` },         },       });     });     Return NextResponse.json({ success: true, instancePath: instance.instancePath });   } catch (error) {     console.error(‘Ralph start error:’, error);     Return NextResponse.json(       { error: ‘Failed to start Ralph’ },       { status: 500 }     );   } } \`\`\` \#\# Environment Variables \`\`\`env \# .env DATABASE\_URL=”postgresql://user:password@localhost:5432/ralphblaster” \# Optional: Claude API key if not using CLI auth ANTHROPIC\_API\_KEY=”sk-ant-...” \`\`\` \#\# Getting Started Commands \`\`\`bash \# Initialize project Npx create-next-app@latest ralphblaster –typescript –tailwind –app \# Install dependencies Npm install @prisma/client @dnd-kit/core @dnd-kit/sortable \# Install dev dependencies Npm install \-D prisma \# Initialize Prisma Npx prisma init \# After adding schema, run migration Npx prisma migrate dev –name init \# Generate Prisma client Npx prisma generate \# Run development server Npm run dev \`\`\` \#\# Success Criteria 1\. User can create projects with codebase paths 2\. User can create tickets with title and description 3\. Kanban board displays tickets in correct columns 4\. Drag-and-drop updates ticket status 5\. “Generate PRD” button creates structured PRD via Claude CLI 6\. “Start Ralph” button initiates autonomous execution 7\. Real-time progress updates shown in UI 8\. Ticket auto-moves to “In Testing” on completion 9\. Ralph instance files cleaned up after completion \#\# Notes for Claude Code \- Use \`claude –print\` for non-interactive PRD generation \- Use \`claude –dangerously-skip-permissions\` for autonomous execution (with user consent) \- Create git worktrees for isolated development \- Log all progress to [progress.md](http://progress.md) file \- Commit after each completed task \- Handle errors gracefully with retry logicPerson Person Person |
| ----- | :---- |
| **Cc** | Person |
| **Bcc** | Person |
| **Subject** |  |
|  |  |

